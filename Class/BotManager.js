const fs = require('fs');
const events = require('events');

const Bot = require('./Bot.js');
const CommandManager = require('./CommandManager');
const Command = require('./Command.js');
const EventManager = require('./EventManager');
const Event = require('./Event.js');
const EmoteMessageManager = require('./EmoteMessageManager');

const SelfApi = require('../SelfApi/Api.js');

//const EmoteMessage = require("./EmoteMessage.js");

/**
 * Configure les gestionnaires de commandes, √©v√©nements, et messages d'√©mote.
 */
module.exports = class BotManager extends Map {
	constructor() {
		super();
		/**
		 * √âmetteur d'√©v√©nements pour g√©rer les √©v√©nements globaux du BotManager.
		 * @type {EventEmitter}
		 */
		this.event = new events.EventEmitter();

		/**
		 * Gestionnaire de commandes pour l'ensemble des bots, g√®re les commandes et leur ex√©cution.
		 * @type {CommandManager}
		 */
		this.Commands = new CommandManager();

		/**
		 * Gestionnaire d'√©v√©nements, initialis√© avec une r√©f√©rence au BotManager.
		 * Configure les √©v√©nements pour chaque bot.
		 * @type {EventManager}
		 */
		this.Events = new EventManager(this);

		/**
		 * Gestionnaire des messages d'√©motes, permettant de configurer les r√©ponses d'√©mote pour chaque bot.
		 * Initialis√© avec une r√©f√©rence au BotManager.
		 * @type {EmoteMessageManager}
		 */
		this.EmoteMessages = new EmoteMessageManager(this);
	}

	/**
	 * Initialise et d√©marre tous les bots.
	 * Cette fonction cr√©e toutes les instances de bot, configure les commandes et les √©v√©nements,
	 * puis charge les modules associ√©s √† chaque bot.
	 * @param {Map<string, object>} botsData - Une map contenant les donn√©es de configuration de chaque bot.
	 */
	async start(botsData) {
		this.createAllBot(botsData);

		this.Commands.setAllCommands();
		this.Events.setAllEvents();

		this.event.on('botsReady', () => {
			this.EmoteMessages.setAllEmoteMessages();
		});

		this.Events.createAllListenerForAllBot();
		this.loadModules();
	}
	/**
	 * D√©termine le bot "ma√Ætre" pour une ressource Discord donn√©e, en priorit√© celui dont le "home" correspond au serveur.
	 * @param {string} [guildId] - L'ID du serveur.
	 * @param {string} [channelId] - L'ID du salon.
	 * @param {string} [messageId] - L'ID du message.
	 * @returns {Promise<{bot: Bot, guild?: import('discord.js').Guild, channel?: import('discord.js').TextChannel, message?: import('discord.js').Message}|undefined>} L'objet de donn√©es d'acc√®s du bot ma√Ætre, ou undefined si aucun bot n'a acc√®s.
	 */
	async getMasterBot(guildId, channelId, messageId) {
		let dataFromBot = await this.checkBotsAccess(guildId, channelId, messageId);

		// Priorit√© au bot home
		let data =
			dataFromBot.find(
				(d) =>
					d.channel.client?.home ==
					(d.message?.guild.id || d.channel?.guild.id || d.guild?.id)
			) || dataFromBot[0];

		return data;
	}

	/**
	 * Charge les modules pour tout les bots
	 * @returns
	 */
	loadModules() {
		for (let [id, bot] of this) {
			// TEST =================================================================================================
			// if (bot.name !== 'OlympeBot') continue;
			// TEST =================================================================================================

			for (let moduleName in bot.modules) {
				if (!bot.modules[moduleName]) return;
				this.loadModule(bot, moduleName);
			}
		}
	}

	/**
	 * Charge un module pour un bot d√©finit
	 * @param {Bot} bot
	 * @param {Object || Boolean} module
	 */
	loadModule(bot, moduleName) {
		let botModule;

		try {
			botModule = require(`../Modules/${moduleName}`);
			let commandAndEvent = botModule(bot); // TODO ne gere pas si la commande est asynchrone
			// console.log(`ü§ñ [${bot.name}] module ${moduleName} charg√©`);
			for (let ii in commandAndEvent) {
				this.use(commandAndEvent[ii], bot); //TODO ! Dasn le cas ou plusieurs bot on els meme module cela d√©clenche un erreur quand il essaie d'int√©gerer event et command
			}
		} catch (e) {
			bot.error(`Le module est inutilisable : ` + e.stack, moduleName);
		}
	}

	/**
	 * Cr√©e et enregistre une nouvelle instance de bot.
	 * @param {object} data - Donn√©es de configuration pour le bot.
	 * @param {BotManager} BOTS - L'instance du gestionnaire de bots.
	 * @returns {Bot} L'instance du bot cr√©√©.
	 */
	createBot(data, BOTS) {
		let bot = new Bot(data, BOTS);
		this.set(data.getID(), bot);
		return bot;
	}

	/**
	 * Cr√©e toutes les instances de bot √† partir de leurs donn√©es de configuration.
	 * Seuls les bots marqu√©s comme "actifs" sont cr√©√©s.
	 * @param {Map<string, object>} botsData - Une map contenant les donn√©es de configuration de chaque bot.
	 */
	createAllBot(botsData) {
		for (let [id, botData] of botsData) {
			try {
				if (botData.active) this.createBot(botData, this);
			} catch (e) {
				this.error(
					`Les donn√©es fournit n'ont pas permis de creer un bot` +
						JSON.stringify(botData) +
						e.stack,
					'createAllBot'
				);
			}
		}
	}

	/**
	 * Arrete le bot indiqu√© par l'identifiant
	 * @param {String} id Identifiant de bot
	 */
	stop(id) {
		let data = this.get(id).data;
		this.get(id).destroy();
		this.delete(id);
		this.log(`‚úÖ Bot ${data.name} est stop√©`, 'stop');
	}

	/**
	 * Redemarre le bot indiqu√© par l'identifiant
	 * @param {String} id Identifiant de bot
	 */
	restart(id) {
		let data = this.get(id).data;
		this.stop(id);
		this.createBot(data, this);
		this.log(`‚úÖ Bot ${data.name} est rafraichit`, 'restart');
	}

	/**
	 * Permettre l'usage a l'int√©gralit√© des bots, d'un evenement ou d'une commande
	 * @param {Command || Event} data une class heritant des commands ou des events
	 * @param {Bot} bot instance de bot auquel rattach√© l'evenement (si undefined, tout les bots )
	 */
	use(data, bot) {
		try {
			if (data.prototype instanceof Command) return this.Commands.add(data.id, data);
			if (data.prototype instanceof Event) {
				if (!this.Events.get(data.id)) this.Events.add(data.id, data);
				if (bot) return this.Events.createListener(data, bot);
				this.Events.addListenerForAllBot(data);
			}
		} catch (e) {
			this.error(`Impossible d'utiliser ${data.id}:` + e.stack, 'BotManager.use');
		}
	}

	/**
	 * V√©rifie quels bots ont acc√®s √† une ressource Discord sp√©cifique.
	 * @param {string} [guildId] - L'ID du serveur.
	 * @param {string} [channelId] - L'ID du salon.
	 * @param {string} [messageId] - L'ID du message.
	 * @returns {Promise<Array<{bot: Bot, guild?: import('discord.js').Guild, channel?: import('discord.js').TextChannel, message?: import('discord.js').Message}>>} Un tableau d'objets contenant le bot et les ressources accessibles.
	 */
	async checkBotsAccess(guildId, channelId, messageId) {
		let dataFromBot = [];
		for (let [id, bot] of this) {
			let data = await bot.checkAccess(guildId, channelId, messageId);
			if (data) dataFromBot.push({ bot, ...data });
		}
		return dataFromBot;
	}

	/**
	 * Lance l'api du gestionnaire de bot
	 * @param {configs} configs
	 * @param {configs} discord
	 * @param {Number} saltRounds
	 */
	startApi(configs, discord, saltRounds) {
		try {
			this.API = new SelfApi(configs, discord, this, saltRounds);
		} catch (e) {
			this.error('Erreur API Bot : '+ e.stack, 'startApi');
		}
	}

	/**
	 * Met la r√©f√©rence et le contenu au bon format
	 * @param {String || Error} content
	 * @param {String} reference
	 * @returns
	 */
	formatLog(content, reference) {
		if (content instanceof Error) content = '‚ùå ' + content.stack;
		return `[BOTMANAGER] ${reference ? reference.toUpperCase() + ' ' : ''}| ${content}`;
	}

	/**
	 * Diffuse un log
	 * @param {String} content
	 * @param {String} reference
	 */
	log(content, reference) {
		console.log(this.formatLog(content, reference));
	}

	/**
	 * Diffuse une erreur
	 * @param {String || Error} content
	 * @param {String} reference
	 */
	error(content, reference) {
		console.error(this.formatLog(content, reference));
	}
};
